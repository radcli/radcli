.\" File automatically generated by doxy2man0.3
.\" Generation date: Sun Jan 29 2023
.TH radcli.h 3 2023-01-29 "radcli" "Radius client library"
.SH "NAME"
radcli.h \- 
.SH SYNOPSIS
.nf
.B #include <radcli/radcli.h>
.fi
.SH DESCRIPTION
.PP
.sp
.RS
.nf
\fB
int            rc_aaa(rc_handle *, uint32_t, VALUE_PAIR *, VALUE_PAIR **, char *, int, rc_standard_codes);
int            rc_aaa_ctx(rc_handle *, RC_AAA_CTX **, uint32_t, VALUE_PAIR *, VALUE_PAIR **, char *, int, rc_standard_codes);
void           rc_aaa_ctx_free(RC_AAA_CTX *);
const char    *rc_aaa_ctx_get_secret(RC_AAA_CTX *);
const void    *rc_aaa_ctx_get_vector(RC_AAA_CTX *);
int            rc_aaa_ctx_server(rc_handle *, RC_AAA_CTX **, SERVER *, rc_type, uint32_t, VALUE_PAIR *, VALUE_PAIR **, char *, int, rc_standard_codes);
int            rc_acct(rc_handle *, uint32_t, VALUE_PAIR *);
int            rc_acct_proxy(rc_handle *, VALUE_PAIR *);
int            rc_add_config(rc_handle *, char const *, char const *, char const *, int);
int            rc_apply_config(rc_handle *);
int            rc_auth(rc_handle *, uint32_t, VALUE_PAIR *, VALUE_PAIR **, char *);
int            rc_auth_proxy(rc_handle *, VALUE_PAIR *, VALUE_PAIR **, char *);
VALUE_PAIR    *rc_avpair_add(rc_handle const *, VALUE_PAIR **, uint32_t, void const *, int, uint32_t);
int            rc_avpair_assign(VALUE_PAIR *, void const *, int);
VALUE_PAIR    *rc_avpair_copy(VALUE_PAIR *);
void           rc_avpair_free(VALUE_PAIR *);
VALUE_PAIR    *rc_avpair_gen(rc_handle const *, VALUE_PAIR *, unsigned char const *, int, uint32_t);
VALUE_PAIR    *rc_avpair_get(VALUE_PAIR *, uint32_t, uint32_t);
void           rc_avpair_get_attr(VALUE_PAIR *, unsigned *, unsigned *);
int            rc_avpair_get_in6(VALUE_PAIR *, struct in6_addr *, unsigned *);
int            rc_avpair_get_raw(VALUE_PAIR *, char **, unsigned *);
int            rc_avpair_get_uint32(VALUE_PAIR *, uint32_t *);
void           rc_avpair_insert(VALUE_PAIR **, VALUE_PAIR *, VALUE_PAIR *);
char          *rc_avpair_log(rc_handle const *, VALUE_PAIR *, char *, size_t);
VALUE_PAIR    *rc_avpair_new(rc_handle const *, uint32_t, void const *, int, uint32_t);
VALUE_PAIR    *rc_avpair_next(VALUE_PAIR *);
int            rc_avpair_parse(rc_handle const *, char const *, VALUE_PAIR **);
void           rc_avpair_remove(VALUE_PAIR **, uint32_t, uint32_t);
int            rc_avpair_tostr(rc_handle const *, VALUE_PAIR *, char *, int, char *, int);
void           rc_buildreq(rc_handle const *, SEND_DATA *, int, char *, unsigned short, char *, int, int);
int            rc_check(rc_handle *, char *, char *, unsigned short, char *);
int            rc_check_tls(rc_handle *);
int            rc_conf_int(rc_handle const *, char const *);
SERVER        *rc_conf_srv(rc_handle const *, char const *);
char          *rc_conf_str(rc_handle const *, char const *);
void           rc_config_free(rc_handle *);
rc_handle     *rc_config_init(rc_handle *);
void           rc_destroy(rc_handle *);
DICT_ATTR     *rc_dict_addattr(rc_handle *, char const *, uint32_t, int, uint32_t);
DICT_VALUE    *rc_dict_addval(rc_handle *, char const *, char const *, uint32_t);
DICT_VENDOR   *rc_dict_addvend(rc_handle *, char const *, uint32_t);
DICT_ATTR     *rc_dict_findattr(rc_handle const *, char const *);
DICT_VALUE    *rc_dict_findval(rc_handle const *, char const *);
DICT_VENDOR   *rc_dict_findvend(rc_handle const *, char const *);
void           rc_dict_free(rc_handle *);
DICT_ATTR     *rc_dict_getattr(rc_handle const *, uint64_t);
DICT_VALUE    *rc_dict_getval(rc_handle const *, uint32_t, char const *);
DICT_VENDOR   *rc_dict_getvend(rc_handle const *, uint32_t);
int            rc_find_server_addr(rc_handle const *, char const *, struct addrinfo **, char *, rc_type);
rc_socket_type rc_get_socket_type(rc_handle *);
int            rc_get_srcaddr(struct sockaddr *, const struct sockaddr *);
unsigned short rc_getport(int);
char          *rc_mksid(void);
rc_handle     *rc_new(void);
void           rc_openlog(char const *);
int            rc_own_hostname(char *, int);
rc_handle     *rc_read_config(char const *);
int            rc_read_dictionary(rc_handle *, char const *);
int            rc_read_dictionary_from_buffer(rc_handle *, char const *, size_t);
int            rc_send_server(rc_handle *, SEND_DATA *, char *, rc_type);
void           rc_setdebug(int);
int            rc_test_config(rc_handle *, char const *);
int            rc_tls_fd(rc_handle *);
\fP
.fi
.RE
.SS ""
.PP
.sp
.sp
.RS
.nf
\fB
struct send_data {
  uint8_t      \fIcode\fP;          // RADIUS packet code. 
  uint8_t      \fIseq_nbr\fP;       // Packet sequence number. 
  char        *\fIserver\fP;        // Name/address of RADIUS server. 
  int          \fIsvc_port\fP;      // RADIUS protocol destination port. 
  char        *\fIsecret\fP;        // Shared secret of RADIUS server. 
  int          \fItimeout\fP;       // Session timeout in seconds. 
  int          \fIretries\fP;
  VALUE_PAIR  *\fIsend_pairs\fP;    // More a/v pairs to send. 
  VALUE_PAIR  *\fIreceive_pairs\fP; // Where to place received a/v pairs. 
};
\fP
.fi
.RE
.SS ""
.PP
.sp
.PP 
Avoid using this structure directly, it is included for backwards compatibility only. Several of its fields have been deprecated. 
.sp
.RS
.nf
\fB
struct server {
  int      \fImax\fP;
  char    *\fIname\fP[RC_SERVER_MAX];
  uint16_t \fIport\fP[RC_SERVER_MAX];
  char    *\fIsecret\fP[RC_SERVER_MAX];
  double   \fIdeadtime_ends\fP[RC_SERVER_MAX]; // unused 
};
\fP
.fi
.RE
.SS ""
.PP
.sp
.PP 
Avoid using this structure directly. Use the rc_avpair_get_ functions. 
.sp
.RS
.nf
\fB
struct rc_value_pair {
  char                   \fIname\fP[RC_NAME_LENGTH+1];      // attribute name if known. 
  uint64_t               \fIattribute\fP; // attribute numeric value of type rc_attr_id including vendor; use VENDOR() and ATTRID() to separate. 
  rc_attr_type           \fItype\fP;      // attribute type. 
  uint32_t               \fIlvalue\fP;    // attribute value if type is PW_TYPE_INTEGER, PW_TYPE_DATE or PW_TYPE_IPADDR. 
  char                   \fIstrvalue\fP[AUTH_STRING_LEN+1];  // contains attribute value in other cases. 
  struct rc_value_pair  *\fInext\fP;
  char                   \fIpad\fP[32];       // unused pad 
};
\fP
.fi
.RE
.SH SEE ALSO
.PP
.nh
.ad l
\fIrc_aaa\fP(3), \fIrc_aaa_ctx\fP(3), \fIrc_aaa_ctx_free\fP(3), \fIrc_aaa_ctx_get_secret\fP(3), \fIrc_aaa_ctx_get_vector\fP(3), \fIrc_aaa_ctx_server\fP(3), \fIrc_acct\fP(3), \fIrc_acct_proxy\fP(3), \fIrc_add_config\fP(3), \fIrc_apply_config\fP(3), \fIrc_auth\fP(3), \fIrc_auth_proxy\fP(3), \fIrc_avpair_add\fP(3), \fIrc_avpair_assign\fP(3), \fIrc_avpair_copy\fP(3), \fIrc_avpair_free\fP(3), \fIrc_avpair_gen\fP(3), \fIrc_avpair_get\fP(3), \fIrc_avpair_get_attr\fP(3), \fIrc_avpair_get_in6\fP(3), \fIrc_avpair_get_raw\fP(3), \fIrc_avpair_get_uint32\fP(3), \fIrc_avpair_insert\fP(3), \fIrc_avpair_log\fP(3), \fIrc_avpair_new\fP(3), \fIrc_avpair_next\fP(3), \fIrc_avpair_parse\fP(3), \fIrc_avpair_remove\fP(3), \fIrc_avpair_tostr\fP(3), \fIrc_buildreq\fP(3), \fIrc_check\fP(3), \fIrc_check_tls\fP(3), \fIrc_conf_int\fP(3), \fIrc_conf_srv\fP(3), \fIrc_conf_str\fP(3), \fIrc_config_free\fP(3), \fIrc_config_init\fP(3), \fIrc_destroy\fP(3), \fIrc_dict_addattr\fP(3), \fIrc_dict_addval\fP(3), \fIrc_dict_addvend\fP(3), \fIrc_dict_findattr\fP(3), \fIrc_dict_findval\fP(3), \fIrc_dict_findvend\fP(3), \fIrc_dict_free\fP(3), \fIrc_dict_getattr\fP(3), \fIrc_dict_getval\fP(3), \fIrc_dict_getvend\fP(3), \fIrc_find_server_addr\fP(3), \fIrc_get_socket_type\fP(3), \fIrc_get_srcaddr\fP(3), \fIrc_getport\fP(3), \fIrc_mksid\fP(3), \fIrc_new\fP(3), \fIrc_openlog\fP(3), \fIrc_own_hostname\fP(3), \fIrc_read_config\fP(3), \fIrc_read_dictionary\fP(3), \fIrc_read_dictionary_from_buffer\fP(3), \fIrc_send_server\fP(3), \fIrc_setdebug\fP(3), \fIrc_test_config\fP(3), \fIrc_tls_fd\fP(3)
.ad
.hy
